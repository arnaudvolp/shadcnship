{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "notification-01",
  "title": "Notification 01",
  "description": "A notification center with bell trigger, unread badge, category tabs, and real-time Supabase subscription support",
  "dependencies": [
    "lucide-react"
  ],
  "registryDependencies": [
    "button",
    "popover",
    "tabs",
    "badge",
    "avatar",
    "scroll-area",
    "skeleton",
    "dropdown-menu"
  ],
  "files": [
    {
      "path": "src/registry/blocks/notification-01/notification.tsx",
      "content": "\"use client\";\n\nimport { useState } from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\nimport { Skeleton } from \"@/components/ui/skeleton\";\nimport { CheckCheck } from \"lucide-react\";\nimport {\n  NotificationTrigger,\n  NotificationList,\n} from \"./components\";\nimport type { Notification, NotificationCategory, NotificationProps } from \"./types/notification\";\n\n// =============================================================================\n// Demo Notifications Data\n// =============================================================================\n\nconst demoNotifications: Notification[] = [\n  {\n    id: \"1\",\n    type: \"mention\",\n    title: \"New mention\",\n    message: \"Sarah mentioned you in a comment: \\\"@you Can you review this PR?\\\"\",\n    read: false,\n    createdAt: new Date(Date.now() - 5 * 60 * 1000).toISOString(),\n    sender: { name: \"Sarah Connor\", avatar: \"https://avatar.vercel.sh/sarah\" },\n    action: { label: \"View comment\", href: \"#\" },\n  },\n  {\n    id: \"2\",\n    type: \"success\",\n    title: \"Deployment successful\",\n    message: \"Your project was deployed to production successfully.\",\n    read: false,\n    createdAt: new Date(Date.now() - 30 * 60 * 1000).toISOString(),\n    action: { label: \"View deployment\", href: \"#\" },\n  },\n  {\n    id: \"3\",\n    type: \"info\",\n    title: \"New team member\",\n    message: \"John Doe has joined your team as a developer.\",\n    read: true,\n    createdAt: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),\n    sender: { name: \"John Doe\", avatar: \"https://avatar.vercel.sh/john\" },\n  },\n  {\n    id: \"4\",\n    type: \"warning\",\n    title: \"API rate limit warning\",\n    message: \"You've used 80% of your API quota. Consider upgrading your plan.\",\n    read: true,\n    createdAt: new Date(Date.now() - 5 * 60 * 60 * 1000).toISOString(),\n    action: { label: \"Upgrade plan\", href: \"#\" },\n  },\n  {\n    id: \"5\",\n    type: \"error\",\n    title: \"Build failed\",\n    message: \"The latest build for project-x failed. Check the logs for details.\",\n    read: true,\n    createdAt: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),\n    action: { label: \"View logs\", href: \"#\" },\n  },\n  {\n    id: \"6\",\n    type: \"system\",\n    title: \"Scheduled maintenance\",\n    message: \"We'll perform scheduled maintenance on Sunday at 2:00 AM UTC.\",\n    read: true,\n    createdAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),\n  },\n];\n\n// =============================================================================\n// Demo Actions\n// =============================================================================\n\nconst createDemoActions = (\n  notifications: Notification[],\n  setNotifications: React.Dispatch<React.SetStateAction<Notification[]>>\n) => ({\n  onMarkAsRead: async (id: string) => {\n    await new Promise((resolve) => setTimeout(resolve, 200));\n    setNotifications((prev) =>\n      prev.map((n) => (n.id === id ? { ...n, read: true } : n))\n    );\n  },\n  onMarkAsUnread: async (id: string) => {\n    await new Promise((resolve) => setTimeout(resolve, 200));\n    setNotifications((prev) =>\n      prev.map((n) => (n.id === id ? { ...n, read: false } : n))\n    );\n  },\n  onMarkAllAsRead: async () => {\n    await new Promise((resolve) => setTimeout(resolve, 200));\n    setNotifications((prev) => prev.map((n) => ({ ...n, read: true })));\n  },\n  onDelete: async (id: string) => {\n    await new Promise((resolve) => setTimeout(resolve, 200));\n    setNotifications((prev) => prev.filter((n) => n.id !== id));\n  },\n});\n\n// =============================================================================\n// Loading Skeleton\n// =============================================================================\n\nfunction NotificationSkeleton() {\n  return (\n    <div className=\"space-y-3 p-3\">\n      {[1, 2, 3].map((i) => (\n        <div key={i} className=\"flex gap-3\">\n          <Skeleton className=\"size-9 rounded-full shrink-0\" />\n          <div className=\"flex-1 space-y-2\">\n            <Skeleton className=\"h-4 w-3/4\" />\n            <Skeleton className=\"h-3 w-full\" />\n            <Skeleton className=\"h-3 w-1/4\" />\n          </div>\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// =============================================================================\n// Main Component\n// =============================================================================\n\nexport default function Notification01({\n  notifications: propNotifications,\n  unreadCount: propUnreadCount,\n  isLoading = false,\n  onMarkAsRead,\n  onMarkAsUnread,\n  onMarkAllAsRead,\n  onDelete,\n  className,\n}: NotificationProps) {\n  const [open, setOpen] = useState(false);\n  const [activeTab, setActiveTab] = useState<NotificationCategory>(\"all\");\n  const [internalNotifications, setInternalNotifications] = useState(demoNotifications);\n\n  // Use props if provided, otherwise use internal state\n  const notifications = propNotifications ?? internalNotifications;\n  const unreadCount = propUnreadCount ?? notifications.filter((n) => !n.read).length;\n\n  // Create demo actions if not provided\n  const demoActions = createDemoActions(internalNotifications, setInternalNotifications);\n  const handleMarkAsRead = onMarkAsRead ?? demoActions.onMarkAsRead;\n  const handleMarkAsUnread = onMarkAsUnread ?? demoActions.onMarkAsUnread;\n  const handleMarkAllAsRead = onMarkAllAsRead ?? demoActions.onMarkAllAsRead;\n  const handleDelete = onDelete ?? demoActions.onDelete;\n\n  return (\n    <div className={cn(\"inline-flex\", className)}>\n      <Popover open={open} onOpenChange={setOpen}>\n        <PopoverTrigger asChild>\n          <NotificationTrigger unreadCount={unreadCount} />\n        </PopoverTrigger>\n        <PopoverContent className=\"w-[380px] p-0\" align=\"end\">\n          {/* Header */}\n          <div className=\"flex items-center justify-between px-4 py-3 border-b\">\n            <h3 className=\"font-semibold\">Notifications</h3>\n            {unreadCount > 0 && (\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"h-auto py-1 px-2 text-xs\"\n                onClick={handleMarkAllAsRead}\n              >\n                <CheckCheck className=\"size-3.5 mr-1\" />\n                Mark all read\n              </Button>\n            )}\n          </div>\n\n          {/* Tabs */}\n          <Tabs\n            value={activeTab}\n            onValueChange={(v) => setActiveTab(v as NotificationCategory)}\n          >\n            <TabsList className=\"w-full justify-start rounded-none border-b bg-transparent p-0\">\n              <TabsTrigger\n                value=\"all\"\n                className=\"rounded-none border-b-2 border-transparent data-[state=active]:border-primary data-[state=active]:bg-transparent\"\n              >\n                All\n              </TabsTrigger>\n              <TabsTrigger\n                value=\"unread\"\n                className=\"rounded-none border-b-2 border-transparent data-[state=active]:border-primary data-[state=active]:bg-transparent\"\n              >\n                Unread\n                {unreadCount > 0 && (\n                  <span className=\"ml-1.5 rounded-full bg-primary/10 px-1.5 py-0.5 text-xs text-primary\">\n                    {unreadCount}\n                  </span>\n                )}\n              </TabsTrigger>\n              <TabsTrigger\n                value=\"mentions\"\n                className=\"rounded-none border-b-2 border-transparent data-[state=active]:border-primary data-[state=active]:bg-transparent\"\n              >\n                Mentions\n              </TabsTrigger>\n            </TabsList>\n\n            {isLoading ? (\n              <NotificationSkeleton />\n            ) : (\n              <>\n                <TabsContent value=\"all\" className=\"m-0\">\n                  <NotificationList\n                    notifications={notifications}\n                    category=\"all\"\n                    onMarkAsRead={handleMarkAsRead}\n                    onMarkAsUnread={handleMarkAsUnread}\n                    onDelete={handleDelete}\n                  />\n                </TabsContent>\n                <TabsContent value=\"unread\" className=\"m-0\">\n                  <NotificationList\n                    notifications={notifications}\n                    category=\"unread\"\n                    onMarkAsRead={handleMarkAsRead}\n                    onMarkAsUnread={handleMarkAsUnread}\n                    onDelete={handleDelete}\n                  />\n                </TabsContent>\n                <TabsContent value=\"mentions\" className=\"m-0\">\n                  <NotificationList\n                    notifications={notifications}\n                    category=\"mentions\"\n                    onMarkAsRead={handleMarkAsRead}\n                    onMarkAsUnread={handleMarkAsUnread}\n                    onDelete={handleDelete}\n                  />\n                </TabsContent>\n              </>\n            )}\n          </Tabs>\n\n          {/* Footer */}\n          <div className=\"border-t p-2\">\n            <Button variant=\"ghost\" size=\"sm\" className=\"w-full text-xs\">\n              View all notifications\n            </Button>\n          </div>\n        </PopoverContent>\n      </Popover>\n    </div>\n  );\n}\n\n// =============================================================================\n// Named Exports\n// =============================================================================\n\nexport { Notification01 };\n\n// Re-export types\nexport type {\n  Notification,\n  NotificationType,\n  NotificationCategory,\n  NotificationProps,\n} from \"./types/notification\";\n",
      "type": "registry:component",
      "target": "components/notification-01/notification.tsx"
    },
    {
      "path": "src/registry/blocks/notification-01/types/notification.ts",
      "content": "// =============================================================================\n// Notification Types\n// =============================================================================\n\nexport type NotificationType = \"info\" | \"success\" | \"warning\" | \"error\" | \"mention\" | \"system\";\n\nexport type NotificationCategory = \"all\" | \"unread\" | \"mentions\";\n\nexport interface Notification {\n  id: string;\n  type: NotificationType;\n  title: string;\n  message: string;\n  read: boolean;\n  createdAt: string;\n  avatar?: string;\n  sender?: {\n    name: string;\n    avatar?: string;\n  };\n  action?: {\n    label: string;\n    href: string;\n  };\n}\n\nexport interface NotificationState {\n  notifications: Notification[];\n  unreadCount: number;\n  isLoading: boolean;\n  error: string | null;\n}\n\nexport interface NotificationActions {\n  markAsRead: (id: string) => Promise<void>;\n  markAsUnread: (id: string) => Promise<void>;\n  markAllAsRead: () => Promise<void>;\n  deleteNotification: (id: string) => Promise<void>;\n  fetchNotifications: () => Promise<Notification[]>;\n}\n\nexport interface NotificationProps {\n  notifications?: Notification[];\n  unreadCount?: number;\n  isLoading?: boolean;\n  onMarkAsRead?: (id: string) => Promise<void>;\n  onMarkAsUnread?: (id: string) => Promise<void>;\n  onMarkAllAsRead?: () => Promise<void>;\n  onDelete?: (id: string) => Promise<void>;\n  onFetch?: () => Promise<Notification[]>;\n  className?: string;\n}\n",
      "type": "registry:component",
      "target": "components/notification-01/types/notification.ts"
    },
    {
      "path": "src/registry/blocks/notification-01/components/index.ts",
      "content": "// Components\nexport { NotificationTrigger } from \"./notification-trigger\";\nexport { NotificationList } from \"./notification-list\";\nexport { NotificationItem } from \"./notification-item\";\nexport { NotificationEmpty } from \"./notification-empty\";\n\n// Re-export types\nexport type {\n  NotificationType,\n  NotificationCategory,\n  Notification,\n  NotificationState,\n  NotificationActions,\n  NotificationProps,\n} from \"../types/notification\";\n",
      "type": "registry:component",
      "target": "components/notification-01/components/index.ts"
    },
    {
      "path": "src/registry/blocks/notification-01/components/notification-trigger.tsx",
      "content": "\"use client\";\n\nimport { forwardRef } from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport { Button } from \"@/components/ui/button\";\nimport { Bell } from \"lucide-react\";\n\ninterface NotificationTriggerProps {\n  unreadCount: number;\n  onClick?: () => void;\n  className?: string;\n}\n\nexport const NotificationTrigger = forwardRef<HTMLButtonElement, NotificationTriggerProps>(\n  ({ unreadCount, onClick, className }, ref) => {\n    return (\n      <Button\n        ref={ref}\n        variant=\"ghost\"\n        size=\"icon\"\n        onClick={onClick}\n        className={cn(\"relative\", className)}\n      >\n        <Bell className=\"size-5\" />\n        {unreadCount > 0 && (\n          <span className=\"absolute -top-0.5 -right-0.5 flex size-5 items-center justify-center rounded-full bg-destructive text-[10px] font-medium text-destructive-foreground\">\n            {unreadCount > 99 ? \"99+\" : unreadCount}\n          </span>\n        )}\n        <span className=\"sr-only\">\n          {unreadCount > 0 ? `${unreadCount} unread notifications` : \"Notifications\"}\n        </span>\n      </Button>\n    );\n  }\n);\n\nNotificationTrigger.displayName = \"NotificationTrigger\";\n",
      "type": "registry:component",
      "target": "components/notification-01/components/notification-trigger.tsx"
    },
    {
      "path": "src/registry/blocks/notification-01/components/notification-list.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { NotificationItem } from \"./notification-item\";\nimport { NotificationEmpty } from \"./notification-empty\";\nimport type { Notification, NotificationCategory } from \"../types/notification\";\n\ninterface NotificationListProps {\n  notifications: Notification[];\n  category: NotificationCategory;\n  onMarkAsRead?: (id: string) => void;\n  onMarkAsUnread?: (id: string) => void;\n  onDelete?: (id: string) => void;\n  className?: string;\n}\n\nexport function NotificationList({\n  notifications,\n  category,\n  onMarkAsRead,\n  onMarkAsUnread,\n  onDelete,\n  className,\n}: NotificationListProps) {\n  // Filter notifications based on category\n  const filteredNotifications = notifications.filter((notification) => {\n    if (category === \"all\") return true;\n    if (category === \"unread\") return !notification.read;\n    if (category === \"mentions\") return notification.type === \"mention\";\n    return true;\n  });\n\n  if (filteredNotifications.length === 0) {\n    return <NotificationEmpty category={category} />;\n  }\n\n  return (\n    <ScrollArea className={cn(\"h-[350px]\", className)}>\n      <div className=\"space-y-1 p-1\">\n        {filteredNotifications.map((notification) => (\n          <NotificationItem\n            key={notification.id}\n            notification={notification}\n            onMarkAsRead={onMarkAsRead}\n            onMarkAsUnread={onMarkAsUnread}\n            onDelete={onDelete}\n          />\n        ))}\n      </div>\n    </ScrollArea>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/notification-01/components/notification-list.tsx"
    },
    {
      "path": "src/registry/blocks/notification-01/components/notification-item.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\nimport { Avatar, AvatarFallback, AvatarImage } from \"@/components/ui/avatar\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport {\n  MoreHorizontal,\n  Check,\n  Circle,\n  Trash2,\n  Info,\n  CheckCircle,\n  AlertTriangle,\n  AlertCircle,\n  AtSign,\n  Settings,\n} from \"lucide-react\";\nimport type { Notification, NotificationType } from \"../types/notification\";\n\ninterface NotificationItemProps {\n  notification: Notification;\n  onMarkAsRead?: (id: string) => void;\n  onMarkAsUnread?: (id: string) => void;\n  onDelete?: (id: string) => void;\n  className?: string;\n}\n\nconst typeIcons: Record<NotificationType, typeof Info> = {\n  info: Info,\n  success: CheckCircle,\n  warning: AlertTriangle,\n  error: AlertCircle,\n  mention: AtSign,\n  system: Settings,\n};\n\nconst typeColors: Record<NotificationType, string> = {\n  info: \"text-blue-500\",\n  success: \"text-green-500\",\n  warning: \"text-yellow-500\",\n  error: \"text-red-500\",\n  mention: \"text-purple-500\",\n  system: \"text-muted-foreground\",\n};\n\nexport function NotificationItem({\n  notification,\n  onMarkAsRead,\n  onMarkAsUnread,\n  onDelete,\n  className,\n}: NotificationItemProps) {\n  const Icon = typeIcons[notification.type];\n  const iconColor = typeColors[notification.type];\n\n  const formatTime = (dateString: string) => {\n    const date = new Date(dateString);\n    const now = new Date();\n    const diff = now.getTime() - date.getTime();\n    const minutes = Math.floor(diff / 60000);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n\n    if (minutes < 1) return \"Just now\";\n    if (minutes < 60) return `${minutes}m ago`;\n    if (hours < 24) return `${hours}h ago`;\n    if (days < 7) return `${days}d ago`;\n    return date.toLocaleDateString();\n  };\n\n  return (\n    <div\n      className={cn(\n        \"flex gap-3 p-3 hover:bg-muted/50 transition-colors rounded-lg\",\n        !notification.read && \"bg-muted/30\",\n        className\n      )}\n    >\n      {/* Avatar or Icon */}\n      {notification.sender ? (\n        <Avatar className=\"size-9 shrink-0\">\n          <AvatarImage src={notification.sender.avatar} />\n          <AvatarFallback>{notification.sender.name.slice(0, 2).toUpperCase()}</AvatarFallback>\n        </Avatar>\n      ) : (\n        <div className={cn(\"size-9 shrink-0 rounded-full bg-muted flex items-center justify-center\", iconColor)}>\n          <Icon className=\"size-4\" />\n        </div>\n      )}\n\n      {/* Content */}\n      <div className=\"flex-1 min-w-0 space-y-1\">\n        <div className=\"flex items-start justify-between gap-2\">\n          <p className={cn(\"text-sm font-medium\", !notification.read && \"text-foreground\")}>\n            {notification.title}\n          </p>\n          <div className=\"flex items-center gap-1 shrink-0\">\n            {!notification.read && (\n              <Circle className=\"size-2 fill-primary text-primary\" />\n            )}\n            <DropdownMenu>\n              <DropdownMenuTrigger asChild>\n                <Button variant=\"ghost\" size=\"icon\" className=\"size-6\">\n                  <MoreHorizontal className=\"size-3.5\" />\n                  <span className=\"sr-only\">Actions</span>\n                </Button>\n              </DropdownMenuTrigger>\n              <DropdownMenuContent align=\"end\">\n                {notification.read ? (\n                  <DropdownMenuItem onClick={() => onMarkAsUnread?.(notification.id)}>\n                    <Circle className=\"size-4 mr-2\" />\n                    Mark as unread\n                  </DropdownMenuItem>\n                ) : (\n                  <DropdownMenuItem onClick={() => onMarkAsRead?.(notification.id)}>\n                    <Check className=\"size-4 mr-2\" />\n                    Mark as read\n                  </DropdownMenuItem>\n                )}\n                <DropdownMenuItem\n                  onClick={() => onDelete?.(notification.id)}\n                  className=\"text-destructive focus:text-destructive\"\n                >\n                  <Trash2 className=\"size-4 mr-2\" />\n                  Delete\n                </DropdownMenuItem>\n              </DropdownMenuContent>\n            </DropdownMenu>\n          </div>\n        </div>\n        <p className=\"text-sm text-muted-foreground line-clamp-2\">\n          {notification.message}\n        </p>\n        <p className=\"text-xs text-muted-foreground\">\n          {formatTime(notification.createdAt)}\n        </p>\n        {notification.action && (\n          <a\n            href={notification.action.href}\n            className=\"text-xs font-medium text-primary hover:underline inline-block mt-1\"\n          >\n            {notification.action.label}\n          </a>\n        )}\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/notification-01/components/notification-item.tsx"
    },
    {
      "path": "src/registry/blocks/notification-01/components/notification-empty.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\nimport { Bell, Inbox, AtSign } from \"lucide-react\";\nimport type { NotificationCategory } from \"../types/notification\";\n\ninterface NotificationEmptyProps {\n  category: NotificationCategory;\n  className?: string;\n}\n\nconst emptyStates: Record<NotificationCategory, { icon: typeof Bell; title: string; description: string }> = {\n  all: {\n    icon: Bell,\n    title: \"No notifications\",\n    description: \"You're all caught up! Check back later for updates.\",\n  },\n  unread: {\n    icon: Inbox,\n    title: \"All read\",\n    description: \"You've read all your notifications.\",\n  },\n  mentions: {\n    icon: AtSign,\n    title: \"No mentions\",\n    description: \"No one has mentioned you yet.\",\n  },\n};\n\nexport function NotificationEmpty({ category, className }: NotificationEmptyProps) {\n  const state = emptyStates[category];\n  const Icon = state.icon;\n\n  return (\n    <div className={cn(\"flex flex-col items-center justify-center py-8 text-center\", className)}>\n      <div className=\"size-12 rounded-full bg-muted flex items-center justify-center mb-3\">\n        <Icon className=\"size-6 text-muted-foreground\" />\n      </div>\n      <h3 className=\"text-sm font-medium\">{state.title}</h3>\n      <p className=\"text-xs text-muted-foreground mt-1 max-w-[200px]\">\n        {state.description}\n      </p>\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/notification-01/components/notification-empty.tsx"
    },
    {
      "path": "src/registry/blocks/notification-01/supabase/notification-actions.ts",
      "content": "\"use server\";\n\nimport { createClient } from \"@supabase/supabase-js\";\nimport type { Notification } from \"../types/notification\";\n\n/**\n * Server actions for notification management with Supabase\n *\n * Prerequisites:\n * 1. Set up environment variables:\n *    - SUPABASE_URL\n *    - SUPABASE_SERVICE_ROLE_KEY\n *\n * 2. Create notifications table in Supabase:\n *\n * CREATE TABLE notifications (\n *   id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n *   user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n *   type VARCHAR(20) NOT NULL DEFAULT 'info',\n *   title VARCHAR(255) NOT NULL,\n *   message TEXT NOT NULL,\n *   read BOOLEAN DEFAULT FALSE,\n *   sender_id UUID REFERENCES auth.users(id),\n *   sender_name VARCHAR(255),\n *   sender_avatar TEXT,\n *   action_label VARCHAR(100),\n *   action_href VARCHAR(500),\n *   created_at TIMESTAMPTZ DEFAULT NOW(),\n *   updated_at TIMESTAMPTZ DEFAULT NOW()\n * );\n *\n * -- RLS Policies\n * ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;\n *\n * CREATE POLICY \"Users can view own notifications\" ON notifications\n *   FOR SELECT USING (auth.uid() = user_id);\n *\n * CREATE POLICY \"Users can update own notifications\" ON notifications\n *   FOR UPDATE USING (auth.uid() = user_id);\n *\n * CREATE POLICY \"Users can delete own notifications\" ON notifications\n *   FOR DELETE USING (auth.uid() = user_id);\n *\n * -- Enable realtime\n * ALTER PUBLICATION supabase_realtime ADD TABLE notifications;\n */\n\nconst getSupabase = () => {\n  const supabaseUrl = process.env.SUPABASE_URL;\n  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\n  if (!supabaseUrl || !supabaseServiceKey) {\n    throw new Error(\"Missing Supabase environment variables\");\n  }\n\n  return createClient(supabaseUrl, supabaseServiceKey);\n};\n\nexport async function getNotifications(userId: string): Promise<Notification[]> {\n  const supabase = getSupabase();\n\n  const { data, error } = await supabase\n    .from(\"notifications\")\n    .select(\"*\")\n    .eq(\"user_id\", userId)\n    .order(\"created_at\", { ascending: false })\n    .limit(50);\n\n  if (error) throw new Error(error.message);\n\n  return (data || []).map((row) => ({\n    id: row.id,\n    type: row.type,\n    title: row.title,\n    message: row.message,\n    read: row.read,\n    createdAt: row.created_at,\n    sender: row.sender_name\n      ? { name: row.sender_name, avatar: row.sender_avatar }\n      : undefined,\n    action: row.action_label\n      ? { label: row.action_label, href: row.action_href }\n      : undefined,\n  }));\n}\n\nexport async function markNotificationAsRead(\n  notificationId: string,\n  userId: string\n): Promise<void> {\n  const supabase = getSupabase();\n\n  const { error } = await supabase\n    .from(\"notifications\")\n    .update({ read: true, updated_at: new Date().toISOString() })\n    .eq(\"id\", notificationId)\n    .eq(\"user_id\", userId);\n\n  if (error) throw new Error(error.message);\n}\n\nexport async function markNotificationAsUnread(\n  notificationId: string,\n  userId: string\n): Promise<void> {\n  const supabase = getSupabase();\n\n  const { error } = await supabase\n    .from(\"notifications\")\n    .update({ read: false, updated_at: new Date().toISOString() })\n    .eq(\"id\", notificationId)\n    .eq(\"user_id\", userId);\n\n  if (error) throw new Error(error.message);\n}\n\nexport async function markAllNotificationsAsRead(userId: string): Promise<void> {\n  const supabase = getSupabase();\n\n  const { error } = await supabase\n    .from(\"notifications\")\n    .update({ read: true, updated_at: new Date().toISOString() })\n    .eq(\"user_id\", userId)\n    .eq(\"read\", false);\n\n  if (error) throw new Error(error.message);\n}\n\nexport async function deleteNotification(\n  notificationId: string,\n  userId: string\n): Promise<void> {\n  const supabase = getSupabase();\n\n  const { error } = await supabase\n    .from(\"notifications\")\n    .delete()\n    .eq(\"id\", notificationId)\n    .eq(\"user_id\", userId);\n\n  if (error) throw new Error(error.message);\n}\n\nexport async function getUnreadCount(userId: string): Promise<number> {\n  const supabase = getSupabase();\n\n  const { count, error } = await supabase\n    .from(\"notifications\")\n    .select(\"*\", { count: \"exact\", head: true })\n    .eq(\"user_id\", userId)\n    .eq(\"read\", false);\n\n  if (error) throw new Error(error.message);\n\n  return count || 0;\n}\n",
      "type": "registry:component",
      "target": "components/notification-01/supabase/notification-actions.ts"
    },
    {
      "path": "src/registry/blocks/notification-01/supabase/use-notifications.ts",
      "content": "\"use client\";\n\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { createClient } from \"@supabase/supabase-js\";\nimport type { Notification } from \"../types/notification\";\n\ninterface UseNotificationsOptions {\n  userId?: string;\n  supabaseUrl?: string;\n  supabaseAnonKey?: string;\n  tableName?: string;\n}\n\n/**\n * Real-time notifications hook with Supabase\n *\n * @example\n * // page.tsx\n * import { Notification01 } from \"@/components/notification-01/notification\"\n * import { useNotifications } from \"@/components/notification-01/supabase/use-notifications\"\n *\n * export default function Page() {\n *   const { notifications, unreadCount, isLoading, ...actions } = useNotifications({\n *     userId: \"user-123\"\n *   });\n *\n *   return (\n *     <Notification01\n *       notifications={notifications}\n *       unreadCount={unreadCount}\n *       isLoading={isLoading}\n *       {...actions}\n *     />\n *   );\n * }\n *\n * // Required env vars:\n * // NEXT_PUBLIC_SUPABASE_URL=your-project-url\n * // NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY=your-publishable-key\n */\nexport function useNotifications({\n  userId,\n  supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!,\n  supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!,\n  tableName = \"notifications\",\n}: UseNotificationsOptions = {}) {\n  const [notifications, setNotifications] = useState<Notification[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const supabase = useMemo(\n    () => createClient(supabaseUrl, supabaseAnonKey),\n    [supabaseUrl, supabaseAnonKey]\n  );\n\n  const transformRow = (row: Record<string, unknown>): Notification => ({\n    id: row.id as string,\n    type: row.type as Notification[\"type\"],\n    title: row.title as string,\n    message: row.message as string,\n    read: row.read as boolean,\n    createdAt: row.created_at as string,\n    sender: row.sender_name\n      ? { name: row.sender_name as string, avatar: row.sender_avatar as string | undefined }\n      : undefined,\n    action: row.action_label\n      ? { label: row.action_label as string, href: row.action_href as string }\n      : undefined,\n  });\n\n  const fetchNotifications = useCallback(async () => {\n    if (!userId) return [];\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const { data, error: fetchError } = await supabase\n        .from(tableName)\n        .select(\"*\")\n        .eq(\"user_id\", userId)\n        .order(\"created_at\", { ascending: false })\n        .limit(50);\n\n      if (fetchError) throw new Error(fetchError.message);\n\n      const transformed = (data || []).map(transformRow);\n      setNotifications(transformed);\n      return transformed;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : \"Failed to fetch notifications\");\n      return [];\n    } finally {\n      setIsLoading(false);\n    }\n  }, [supabase, userId, tableName]);\n\n  const markAsRead = useCallback(\n    async (id: string) => {\n      if (!userId) return;\n\n      // Optimistic update\n      setNotifications((prev) =>\n        prev.map((n) => (n.id === id ? { ...n, read: true } : n))\n      );\n\n      const { error: updateError } = await supabase\n        .from(tableName)\n        .update({ read: true })\n        .eq(\"id\", id)\n        .eq(\"user_id\", userId);\n\n      if (updateError) {\n        // Revert on error\n        setNotifications((prev) =>\n          prev.map((n) => (n.id === id ? { ...n, read: false } : n))\n        );\n        throw new Error(updateError.message);\n      }\n    },\n    [supabase, userId, tableName]\n  );\n\n  const markAsUnread = useCallback(\n    async (id: string) => {\n      if (!userId) return;\n\n      setNotifications((prev) =>\n        prev.map((n) => (n.id === id ? { ...n, read: false } : n))\n      );\n\n      const { error: updateError } = await supabase\n        .from(tableName)\n        .update({ read: false })\n        .eq(\"id\", id)\n        .eq(\"user_id\", userId);\n\n      if (updateError) {\n        setNotifications((prev) =>\n          prev.map((n) => (n.id === id ? { ...n, read: true } : n))\n        );\n        throw new Error(updateError.message);\n      }\n    },\n    [supabase, userId, tableName]\n  );\n\n  const markAllAsRead = useCallback(async () => {\n    if (!userId) return;\n\n    const previousNotifications = notifications;\n    setNotifications((prev) => prev.map((n) => ({ ...n, read: true })));\n\n    const { error: updateError } = await supabase\n      .from(tableName)\n      .update({ read: true })\n      .eq(\"user_id\", userId)\n      .eq(\"read\", false);\n\n    if (updateError) {\n      setNotifications(previousNotifications);\n      throw new Error(updateError.message);\n    }\n  }, [supabase, userId, tableName, notifications]);\n\n  const deleteNotification = useCallback(\n    async (id: string) => {\n      if (!userId) return;\n\n      const previousNotifications = notifications;\n      setNotifications((prev) => prev.filter((n) => n.id !== id));\n\n      const { error: deleteError } = await supabase\n        .from(tableName)\n        .delete()\n        .eq(\"id\", id)\n        .eq(\"user_id\", userId);\n\n      if (deleteError) {\n        setNotifications(previousNotifications);\n        throw new Error(deleteError.message);\n      }\n    },\n    [supabase, userId, tableName, notifications]\n  );\n\n  // Initial fetch\n  useEffect(() => {\n    fetchNotifications();\n  }, [fetchNotifications]);\n\n  // Real-time subscription\n  useEffect(() => {\n    if (!userId) return;\n\n    const channel = supabase\n      .channel(`notifications:${userId}`)\n      .on(\n        \"postgres_changes\",\n        {\n          event: \"INSERT\",\n          schema: \"public\",\n          table: tableName,\n          filter: `user_id=eq.${userId}`,\n        },\n        (payload) => {\n          const newNotification = transformRow(payload.new);\n          setNotifications((prev) => [newNotification, ...prev]);\n        }\n      )\n      .on(\n        \"postgres_changes\",\n        {\n          event: \"UPDATE\",\n          schema: \"public\",\n          table: tableName,\n          filter: `user_id=eq.${userId}`,\n        },\n        (payload) => {\n          const updated = transformRow(payload.new);\n          setNotifications((prev) =>\n            prev.map((n) => (n.id === updated.id ? updated : n))\n          );\n        }\n      )\n      .on(\n        \"postgres_changes\",\n        {\n          event: \"DELETE\",\n          schema: \"public\",\n          table: tableName,\n          filter: `user_id=eq.${userId}`,\n        },\n        (payload) => {\n          setNotifications((prev) =>\n            prev.filter((n) => n.id !== (payload.old as { id: string }).id)\n          );\n        }\n      )\n      .subscribe();\n\n    return () => {\n      supabase.removeChannel(channel);\n    };\n  }, [supabase, userId, tableName]);\n\n  const unreadCount = notifications.filter((n) => !n.read).length;\n\n  return {\n    notifications,\n    unreadCount,\n    isLoading,\n    error,\n    onMarkAsRead: markAsRead,\n    onMarkAsUnread: markAsUnread,\n    onMarkAllAsRead: markAllAsRead,\n    onDelete: deleteNotification,\n    onFetch: fetchNotifications,\n  };\n}\n",
      "type": "registry:component",
      "target": "components/notification-01/supabase/use-notifications.ts"
    },
    {
      "path": "src/registry/blocks/notification-01/postgres/notification-actions.ts",
      "content": "\"use server\";\n\n/**\n * Server actions for notification management with PostgreSQL\n *\n * Prerequisites:\n * 1. Set up your database connection (e.g., using pg, drizzle-orm, or prisma)\n * 2. Create notifications table:\n *\n * CREATE TABLE notifications (\n *   id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n *   user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n *   type VARCHAR(20) NOT NULL DEFAULT 'info',\n *   title VARCHAR(255) NOT NULL,\n *   message TEXT NOT NULL,\n *   read BOOLEAN DEFAULT FALSE,\n *   sender_id UUID REFERENCES users(id),\n *   action_label VARCHAR(100),\n *   action_href VARCHAR(500),\n *   created_at TIMESTAMPTZ DEFAULT NOW(),\n *   updated_at TIMESTAMPTZ DEFAULT NOW()\n * );\n *\n * CREATE INDEX idx_notifications_user_id ON notifications(user_id);\n * CREATE INDEX idx_notifications_read ON notifications(user_id, read);\n */\n\nimport type { Notification } from \"../types/notification\";\n\n// Replace with your actual database client\n// import { db } from \"@/lib/db\";\n\nexport async function getNotifications(userId: string): Promise<Notification[]> {\n  // Example implementation with raw SQL:\n  // const result = await db.query(`\n  //   SELECT\n  //     n.id, n.type, n.title, n.message, n.read, n.created_at as \"createdAt\",\n  //     n.action_label, n.action_href,\n  //     u.name as sender_name, u.avatar as sender_avatar\n  //   FROM notifications n\n  //   LEFT JOIN users u ON n.sender_id = u.id\n  //   WHERE n.user_id = $1\n  //   ORDER BY n.created_at DESC\n  //   LIMIT 50\n  // `, [userId]);\n  //\n  // return result.rows.map(row => ({\n  //   id: row.id,\n  //   type: row.type,\n  //   title: row.title,\n  //   message: row.message,\n  //   read: row.read,\n  //   createdAt: row.createdAt,\n  //   sender: row.sender_name ? { name: row.sender_name, avatar: row.sender_avatar } : undefined,\n  //   action: row.action_label ? { label: row.action_label, href: row.action_href } : undefined,\n  // }));\n\n  throw new Error(\"Not implemented - configure your database connection\");\n}\n\nexport async function markNotificationAsRead(notificationId: string, userId: string): Promise<void> {\n  // await db.query(`\n  //   UPDATE notifications\n  //   SET read = TRUE, updated_at = NOW()\n  //   WHERE id = $1 AND user_id = $2\n  // `, [notificationId, userId]);\n\n  throw new Error(\"Not implemented - configure your database connection\");\n}\n\nexport async function markNotificationAsUnread(notificationId: string, userId: string): Promise<void> {\n  // await db.query(`\n  //   UPDATE notifications\n  //   SET read = FALSE, updated_at = NOW()\n  //   WHERE id = $1 AND user_id = $2\n  // `, [notificationId, userId]);\n\n  throw new Error(\"Not implemented - configure your database connection\");\n}\n\nexport async function markAllNotificationsAsRead(userId: string): Promise<void> {\n  // await db.query(`\n  //   UPDATE notifications\n  //   SET read = TRUE, updated_at = NOW()\n  //   WHERE user_id = $1 AND read = FALSE\n  // `, [userId]);\n\n  throw new Error(\"Not implemented - configure your database connection\");\n}\n\nexport async function deleteNotification(notificationId: string, userId: string): Promise<void> {\n  // await db.query(`\n  //   DELETE FROM notifications\n  //   WHERE id = $1 AND user_id = $2\n  // `, [notificationId, userId]);\n\n  throw new Error(\"Not implemented - configure your database connection\");\n}\n\nexport async function getUnreadCount(userId: string): Promise<number> {\n  // const result = await db.query(`\n  //   SELECT COUNT(*) as count\n  //   FROM notifications\n  //   WHERE user_id = $1 AND read = FALSE\n  // `, [userId]);\n  //\n  // return parseInt(result.rows[0].count);\n\n  throw new Error(\"Not implemented - configure your database connection\");\n}\n\nexport async function createNotification(\n  userId: string,\n  data: {\n    type: Notification[\"type\"];\n    title: string;\n    message: string;\n    senderId?: string;\n    action?: { label: string; href: string };\n  }\n): Promise<Notification> {\n  // const result = await db.query(`\n  //   INSERT INTO notifications (user_id, type, title, message, sender_id, action_label, action_href)\n  //   VALUES ($1, $2, $3, $4, $5, $6, $7)\n  //   RETURNING *\n  // `, [userId, data.type, data.title, data.message, data.senderId, data.action?.label, data.action?.href]);\n  //\n  // return result.rows[0];\n\n  throw new Error(\"Not implemented - configure your database connection\");\n}\n",
      "type": "registry:component",
      "target": "components/notification-01/postgres/notification-actions.ts"
    }
  ],
  "meta": {
    "image": "/r/previews/notification-01.webp",
    "stacks": [
      "supabase",
      "postgres"
    ]
  },
  "categories": [
    "notification"
  ],
  "type": "registry:block"
}